# p1
class A 
{ 
    public Top(String s)  
    { 
        System.out.print("A"); 
    } 
} 
  
public class B extends A  
{ 
    public B(String s)  
    { 
        System.out.print("B"); 
    } 
    public static void main(String[] args)  
    { 
        new B("C"); 
        System.out.println(" "); 
    } 
} 
Output: Compilation fails

3: error: invalid method declaration; return type required
    public Top(String s) 
           ^
1 error
Explanation: The implied super() call in B’s constructor cannot be satisfied because there isn’t a no-arg constructor 
in A. A default, no-arg constructor is generated by the compiler only 
if the class has no constructor defined explicitly.For detail See – Constructors in Java

# p2
class Clidder  
{ 
    private final void flipper()  
    { 
        System.out.println("Clidder"); 
    } 
} 
  
public class Clidlet extends Clidder  
{ 
    public final void flipper()  
    { 
        System.out.println("Clidlet"); 
    } 
    public static void main(String[] args)  
    { 
        new Clidlet().flipper(); 
    } 
} 
Output:

Clidlet
Explanation: Although a final method cannot be overridden, in this case, the method is private, 
and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, 
no polymorphism occurs in this example, 
the method invoked is simply that of the child class, and no error occurs.

# p3
class Alpha  
{ 
    static String s = " "; 
    protected Alpha()  
    { 
        s += "alpha "; 
    } 
} 
class SubAlpha extends Alpha  
{ 
    private SubAlpha()  
    { 
        s += "sub "; 
    } 
} 
  
public class SubSubAlpha extends Alpha  
{ 
    private SubSubAlpha()  
    { 
        s += "subsub "; 
    } 
    public static void main(String[] args)  
    { 
        new SubSubAlpha(); 
        System.out.println(s); 
    } 
} 
Output: alpha subsub
Explanation: SubSubAlpha extends Alpha! Since the code doesnt attempt to make a SubAlpha,
the private constructor in SubAlpha is okay.

# p4
public class Juggler extends Thread  
{ 
    public static void main(String[] args)  
    { 
        try 
        { 
            Thread t = new Thread(new Juggler()); 
            Thread t2 = new Thread(new Juggler()); 
        } 
        catch (Exception e)  
        { 
            System.out.print("e "); 
        } 
    } 
    public void run()  
    { 
        for (int i = 0; i < 2; i++)  
        { 
            try 
            { 
                Thread.sleep(500); 
            } 
            catch (Exception e)  
            { 
                System.out.print("e2 "); 
            } 
            System.out.print(Thread.currentThread().getName()+ " "); 
        } 
    } 
} 
Output: No output is produced.
Explanation: In main(), the start() method was never called to start ”t” and ”t2”, so run() never ran.

# p5 
class Grandparent  
{ 
    public void Print()  
    { 
        System.out.println("Grandparent's Print()");  
    }  
} 
  
class Parent extends Grandparent  
{ 
    public void Print()  
    { 
        System.out.println("Parent's Print()");  
    }  
} 
  
class Child extends Parent  
{ 
    public void Print()    
    { 
        super.super.Print(); 
        System.out.println("Child's Print()");  
    }  
} 
  
public class Main  
{ 
    public static void main(String[] args)  
    { 
        Child c = new Child(); 
        c.Print();  
    } 
} 
Output: Compiler Error in super.super.Print()
Explanation: In Java, it is not allowed to do super.super. We can only access Grandparent’s members using Parent
